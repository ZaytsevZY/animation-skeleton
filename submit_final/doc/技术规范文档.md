# 技术规范文档

## 1. 系统架构规范

### 1.1 总体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    骨架绑定系统                              │
├─────────────────┬─────────────────┬─────────────────────────┤
│   表示层        │   业务逻辑层    │       数据访问层         │
│ (UI界面)        │   (核心算法)    │     (文件IO/存储)        │
├─────────────────┼─────────────────┼─────────────────────────┤
│ PyQt5          │ 权重计算        │ 模型加载                │
│ PyVista        │ LBS算法         │ 骨架解析                │
│ OpenGL         │ 变形系统        │ 数据导出                │
│ 事件处理       │ 运动学计算      │ 配置管理                │
└─────────────────┴─────────────────┴─────────────────────────┘
```

### 1.2 模块划分

#### 1.2.1 用户界面模块 (ui_simple.py)
- **职责**：提供3D可视化和交互功能
- **依赖**：PyQt5, PyVista, VTK
- **接口**：
  ```python
  class RiggingUI:
      def __init__(self, model_path: str)
      def setup_ui(self)
      def load_model(self, path: str) -> bool
      def update_display(self)
      def export_data(self, data_type: str, path: str)
  ```

#### 1.2.2 权重计算模块 (weights_*.py)
- **职责**：实现各种权重计算算法
- **依赖**：NumPy, SciPy
- **接口**：
  ```python
  class WeightCalculator:
      def calculate_weights(vertices: np.ndarray, faces: np.ndarray,
                          bones: List[Bone]) -> np.ndarray
      def validate_weights(weights: np.ndarray) -> bool
  ```

#### 1.2.3 线性混合蒙皮模块 (lbs.py)
- **职责**：实现LBS变形算法
- **依赖**：NumPy
- **接口**：
  ```python
  class LBSEngine:
      def apply_skinning(vertices: np.ndarray, weights: np.ndarray,
                        transforms: np.ndarray) -> np.ndarray
      def compute_transforms(joints: List[Joint]) -> np.ndarray
  ```

#### 1.2.4 骨架管理模块 (skeleton.py)
- **职责**：管理骨架层次结构和变换
- **依赖**：NumPy
- **接口**：
  ```python
  class Skeleton:
      def add_joint(name: str, parent: int, offset: np.ndarray) -> int
      def get_global_transforms() -> np.ndarray
      def update_joint_transform(index: int, transform: np.ndarray)
  ```

## 2. 数据格式规范

### 2.1 模型文件格式

#### 2.1.1 支持的文件格式
| 格式 | 扩展名 | 支持骨架 | 支持动画 | 备注 |
|------|--------|----------|----------|------|
| GLTF | .gltf/.glb | ✓ | ✓ | 推荐格式 |
| FBX | .fbx | ✓ | ✓ | Autodesk格式 |
| OBJ | .obj | ✗ | ✗ | 纯网格数据 |

#### 2.1.2 模型要求
- **顶点数**：100-50000个顶点
- **面数**：100-100000个面片
- **坐标范围**：[-10, 10]单位范围内
- **拓扑要求**：流形网格，无自相交

### 2.2 骨架数据格式

#### 2.2.1 JSON格式规范
```json
{
  "format_version": "1.0",
  "skeleton": {
    "joints": [
      {
        "index": 0,
        "name": "root",
        "parent": -1,
        "offset": [0.0, 0.0, 0.0],
        "bind_pose": {
          "translation": [0.0, 0.0, 0.0],
          "rotation": [0.0, 0.0, 0.0, 1.0],
          "scale": [1.0, 1.0, 1.0]
        }
      }
    ],
    "bones": [
      {
        "parent_joint": 0,
        "child_joint": 1,
        "length": 1.0,
        "direction": [0.0, 1.0, 0.0]
      }
    ]
  }
}
```

### 2.3 权重数据格式

#### 2.3.1 存储结构
```json
{
  "format_version": "1.0",
  "metadata": {
    "algorithm": "heat_diffusion",
    "vertex_count": 1000,
    "bone_count": 5,
    "created": "2025-12-31T10:00:00Z"
  },
  "weights": {
    "data": [
      [0.8, 0.2, 0.0, 0.0, 0.0],
      [0.3, 0.7, 0.0, 0.0, 0.0]
    ],
    "indices": [0, 1, 2, 3, 4]
  },
  "bone_names": ["bone_1", "bone_2", "bone_3", "bone_4", "bone_5"]
}
```

#### 2.3.2 权重约束
- 每个顶点的权重和必须为1.0
- 权重值范围：[0.0, 1.0]
- 稀疏存储：权重小于0.001的项可以忽略

## 3. API接口规范

### 3.1 核心API

#### 3.1.1 模型加载接口
```python
from typing import Tuple, List
import numpy as np

class ModelLoader:
    """模型加载器"""

    @staticmethod
    def load_mesh(filepath: str) -> Tuple[np.ndarray, np.ndarray]:
        """
        加载3D模型

        Args:
            filepath: 模型文件路径

        Returns:
            vertices: (N, 3) 顶点坐标
            faces: (M, 3) 面片索引

        Raises:
            FileNotFoundError: 文件不存在
            ValueError: 文件格式不支持或损坏
        """
        pass

    @staticmethod
    def load_skeleton(filepath: str) -> Skeleton:
        """
        加载骨架数据

        Args:
            filepath: 骨架文件路径

        Returns:
            Skeleton: 骨架对象
        """
        pass
```

#### 3.1.2 权重计算接口
```python
from abc import ABC, abstractmethod

class WeightAlgorithm(ABC):
    """权重计算算法基类"""

    @abstractmethod
    def calculate(self,
                  vertices: np.ndarray,
                  faces: np.ndarray,
                  bones: List[Bone]) -> np.ndarray:
        """
        计算权重

        Args:
            vertices: (N, 3) 顶点坐标
            faces: (M, 3) 面片索引
            bones: 骨骼列表

        Returns:
            weights: (N, B) 权重矩阵
        """
        pass

    @abstractmethod
    def get_name(self) -> str:
        """返回算法名称"""
        pass

class NearestWeightAlgorithm(WeightAlgorithm):
    """最近邻权重算法"""
    pass

class HeatDiffusionWeightAlgorithm(WeightAlgorithm):
    """热扩散权重算法"""
    pass
```

#### 3.1.3 变形接口
```python
class DeformationEngine:
    """变形引擎"""

    def __init__(self, vertices: np.ndarray, weights: np.ndarray):
        """
        初始化变形引擎

        Args:
            vertices: (N, 3) 绑定姿势顶点
            weights: (N, B) 权重矩阵
        """
        pass

    def deform(self, joint_transforms: np.ndarray) -> np.ndarray:
        """
        应用变形

        Args:
            joint_transforms: (B, 4, 4) 关节变换矩阵

        Returns:
            deformed_vertices: (N, 3) 变形后的顶点
        """
        pass

    def get_bind_pose(self) -> np.ndarray:
        """返回绑定姿势顶点"""
        pass
```

### 3.2 事件系统

#### 3.2.1 用户交互事件
```python
from enum import Enum
from dataclasses import dataclass

class EventType(Enum):
    JOINT_SELECTED = "joint_selected"
    JOINT_MOVED = "joint_moved"
    WEIGHTS_CHANGED = "weights_changed"
    MODEL_LOADED = "model_loaded"
    VIEWPORT_CLICKED = "viewport_clicked"

@dataclass
class Event:
    type: EventType
    data: dict
    timestamp: float

class EventManager:
    """事件管理器"""

    def subscribe(self, event_type: EventType, callback: callable):
        """订阅事件"""
        pass

    def emit(self, event: Event):
        """触发事件"""
        pass
```

## 4. 性能规范

### 4.1 性能指标

#### 4.1.1 时间性能
| 操作 | 目标时间 | 实际时间 | 备注 |
|------|----------|----------|------|
| 模型加载 | < 2秒 | ~1.5秒 | 10000面模型 |
| 骨架创建 | < 1秒 | ~0.5秒 | 10关节骨架 |
| 最近邻权重 | < 1秒 | ~0.8秒 | 10000顶点 |
| 热扩散权重 | < 30秒 | ~25秒 | 10000顶点 |
| 实时变形 | > 30 FPS | ~60 FPS | 10000顶点 |

#### 4.1.2 内存使用
- **基础内存**：~100MB（程序启动）
- **模型内存**：~10MB/10000顶点
- **权重内存**：~N×B×4字节（N=顶点数，B=骨骼数）
- **缓存内存**：~50MB（临时计算结果）

### 4.2 优化策略

#### 4.2.1 计算优化
- **向量化计算**：使用NumPy向量化操作
- **稀疏矩阵**：权重矩阵使用稀疏存储
- **缓存机制**：缓存常用计算结果
- **并行计算**：关键算法支持多线程

#### 4.2.2 内存优化
```python
# 内存池管理
class MemoryPool:
    def __init__(self, max_size_mb: int = 100):
        self.max_size = max_size_mb * 1024 * 1024
        self.current_usage = 0
        self.pooled_arrays = []

    def get_array(self, shape: tuple, dtype: type) -> np.ndarray:
        """从内存池获取数组"""
        pass

    def release_array(self, array: np.ndarray):
        """释放数组到内存池"""
        pass
```

## 5. 错误处理规范

### 5.1 错误类型

#### 5.1.1 文件相关错误
```python
class FileError(Exception):
    """文件操作错误基类"""
    pass

class ModelLoadError(FileError):
    """模型加载错误"""
    def __init__(self, filepath: str, reason: str):
        super().__init__(f"Failed to load model {filepath}: {reason}")

class SkeletonLoadError(FileError):
    """骨架加载错误"""
    def __init__(self, filepath: str, reason: str):
        super().__init__(f"Failed to load skeleton {filepath}: {reason}")
```

#### 5.1.2 计算相关错误
```python
class ComputationError(Exception):
    """计算错误基类"""
    pass

class WeightCalculationError(ComputationError):
    """权重计算错误"""
    def __init__(self, algorithm: str, reason: str):
        super().__init__(f"Weight calculation failed in {algorithm}: {reason}")

class DeformationError(ComputationError):
    """变形计算错误"""
    def __init__(self, reason: str):
        super().__init__(f"Deformation failed: {reason}")
```

### 5.2 错误处理流程
```python
import logging

class ErrorHandler:
    def __init__(self, log_file: str = "error.log"):
        self.logger = logging.getLogger("rigging")
        handler = logging.FileHandler(log_file)
        self.logger.addHandler(handler)

    def handle_error(self, error: Exception, context: dict = None):
        """统一错误处理"""
        self.logger.error(f"Error: {error}", extra=context)

        if isinstance(error, FileError):
            return self._handle_file_error(error)
        elif isinstance(error, ComputationError):
            return self._handle_computation_error(error)
        else:
            return self._handle_unknown_error(error)
```

## 6. 测试规范

### 6.1 单元测试

#### 6.1.1 权重计算测试
```python
import unittest

class TestWeightAlgorithms(unittest.TestCase):
    def setUp(self):
        self.vertices = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0]])
        self.faces = np.array([[0, 1, 2]])
        self.bones = [Bone([0, 0, 0], [1, 0, 0])]

    def test_nearest_weights(self):
        calculator = NearestWeightAlgorithm()
        weights = calculator.calculate(self.vertices, self.faces, self.bones)

        # 验证权重和为1
        self.assertTrue(np.allclose(np.sum(weights, axis=1), 1.0))

        # 验证权重范围
        self.assertTrue(np.all(weights >= 0))
        self.assertTrue(np.all(weights <= 1))

    def test_heat_diffusion_weights(self):
        calculator = HeatDiffusionWeightAlgorithm()
        weights = calculator.calculate(self.vertices, self.faces, self.bones)

        # 验证权重和为1
        self.assertTrue(np.allclose(np.sum(weights, axis=1), 1.0))
```

### 6.2 集成测试

#### 6.2.1 端到端测试
```python
class TestEndToEnd(unittest.TestCase):
    def test_complete_workflow(self):
        # 1. 加载模型
        vertices, faces = ModelLoader.load_mesh("test_model.obj")

        # 2. 创建骨架
        skeleton = create_test_skeleton()

        # 3. 计算权重
        weights = HeatDiffusionWeightAlgorithm().calculate(
            vertices, faces, skeleton.bones
        )

        # 4. 应用变形
        engine = DeformationEngine(vertices, weights)
        transforms = skeleton.get_global_transforms()
        deformed = engine.deform(transforms)

        # 5. 验证结果
        self.assertEqual(len(deformed), len(vertices))
        self.assertFalse(np.array_equal(vertices, deformed))
```

## 7. 部署规范

### 7.1 环境要求

#### 7.1.1 开发环境
- Python 3.7+
- PyQt5 5.15+
- PyVista 0.40+
- NumPy 1.19+
- SciPy 1.7+

#### 7.1.2 运行环境
- Windows 10/11
- macOS 10.14+
- Ubuntu 18.04+

### 7.2 打包规范

#### 7.2.1 目录结构
```
submit_final/
├── bin/
│   └── run.bat          # Windows启动脚本
├── src/
│   ├── main.py          # 主程序
│   ├── requirements.txt # 依赖列表
│   ├── ui_simple.py     # 用户界面
│   └── rigging/         # 核心模块
├── doc/                 # 文档
├── data/                # 示例数据
└── output/              # 输出目录
```

#### 7.2.2 依赖管理
```txt
# requirements.txt
PyQt5>=5.15.0
pyvista>=0.40.0
numpy>=1.19.0
scipy>=1.7.0
trimesh>=3.9.0
vtk>=9.0.0
```

## 8. 安全规范

### 8.1 输入验证

#### 8.1.1 文件验证
```python
def validate_model_file(filepath: str) -> bool:
    """验证模型文件"""
    if not os.path.exists(filepath):
        return False

    # 检查文件大小
    file_size = os.path.getsize(filepath)
    if file_size > 100 * 1024 * 1024:  # 100MB限制
        return False

    # 检查文件扩展名
    valid_extensions = ['.obj', '.fbx', '.gltf', '.glb']
    ext = os.path.splitext(filepath)[1].lower()
    return ext in valid_extensions
```

#### 8.1.2 数据验证
```python
def validate_weights(weights: np.ndarray) -> bool:
    """验证权重数据"""
    if weights is None or weights.size == 0:
        return False

    # 检查范围
    if np.any(weights < 0) or np.any(weights > 1):
        return False

    # 检查归一化
    row_sums = np.sum(weights, axis=1)
    return np.allclose(row_sums, 1.0, atol=1e-3)
```

### 8.2 错误边界
```python
try:
    vertices, faces = ModelLoader.load_mesh(filepath)
except ModelLoadError as e:
    logger.error(f"Model load failed: {e}")
    show_error_dialog(str(e))
    return None
except Exception as e:
    logger.exception("Unexpected error during model loading")
    show_error_dialog("An unexpected error occurred")
    return None
```

---

**文档版本**：v1.0
**创建日期**：2025年12月31日
**技术标准**：遵循PEP 8编码规范