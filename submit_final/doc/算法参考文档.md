# 算法参考文档

## 骨架绑定算法详解

### 1. 权重计算算法

#### 1.1 最近邻算法（Nearest Neighbor）

**算法原理**：
每个模型表面点只绑定到距离最近的骨骼，权重为二元值（0或1）。

**实现步骤**：

1. **距离计算**：
   对于每个顶点v，计算到每段骨骼的距离

   ```python
   def distance_to_bone(vertex, bone_start, bone_end):
       # 计算点到线段的最短距离
       bone_vec = bone_end - bone_start
       vertex_vec = vertex - bone_start

       # 计算投影长度
       t = max(0, min(1, np.dot(vertex_vec, bone_vec) / np.dot(bone_vec, bone_vec)))
       projection = bone_start + t * bone_vec

       # 返回点到线段的距离
       return np.linalg.norm(vertex - projection)
   ```

2. **权重分配**：
   ```python
   def nearest_weights(vertices, bones):
       n_vertices = len(vertices)
       n_bones = len(bones)
       weights = np.zeros((n_vertices, n_bones))

       for i, vertex in enumerate(vertices):
           min_distance = float('inf')
           closest_bone = 0

           for j, (start, end) in enumerate(bones):
               distance = distance_to_bone(vertex, start, end)
               if distance < min_distance:
                   min_distance = distance
                   closest_bone = j

           weights[i, closest_bone] = 1.0

       return weights
   ```

**优点**：
- 计算简单快速
- 易于理解和实现
- 适合预览和调试

**缺点**：
- 权重过渡不平滑
- 变形效果生硬
- 不适合复杂变形

#### 1.2 双骨插值算法（Dual Bone Interpolation）

**算法原理**：
每个顶点考虑最近的两段骨骼，根据距离进行双线性插值。

**实现步骤**：

1. **寻找最近两骨**：
   ```python
   def find_two_nearest_bones(vertex, bones):
       distances = []
       for j, (start, end) in enumerate(bones):
           distance = distance_to_bone(vertex, start, end)
           distances.append((distance, j))

       # 按距离排序
       distances.sort(key=lambda x: x[0])

       # 返回最近两段骨骼
       if len(distances) >= 2:
           return distances[0][1], distances[1][1], distances[0][0], distances[1][0]
       else:
           return distances[0][1], distances[0][1], distances[0][0], distances[0][0]
   ```

2. **双线性插值**：
   ```python
   def dual_bone_weights(vertices, bones):
       n_vertices = len(vertices)
       n_bones = len(bones)
       weights = np.zeros((n_vertices, n_bones))

       for i, vertex in enumerate(vertices):
           bone1, bone2, dist1, dist2 = find_two_nearest_bones(vertex, bones)

           if dist1 + dist2 > 0:
               w1 = dist2 / (dist1 + dist2)  # 距离越近权重越大
               w2 = dist1 / (dist1 + dist2)
           else:
               w1 = 1.0
               w2 = 0.0

           weights[i, bone1] = w1
           weights[i, bone2] = w2

       return weights
   ```

**优点**：
- 权重过渡较平滑
- 计算相对简单
- 变形效果较好

**缺点**：
- 仍可能产生不自然的变形
- 仅考虑局部骨骼

#### 1.3 热扩散算法（Heat Diffusion）

**算法原理**：
基于热平衡方程，将权重计算转化为热扩散问题，使用离散Laplacian算子求解。

**理论基础**：
- 基于Pinocchio方法（Baran & Popović, 2007）
- 使用cotangent Laplacian算子
- 求解稀疏线性方程组

**实现步骤**：

1. **构建cotangent Laplacian矩阵**：
   ```python
   def cotangent_laplacian(vertices, faces):
       n_vertices = len(vertices)
       I, J, V = [], [], []

       for face in faces:
           i, j, k = face

           # 计算cotangent权重
           v_i = vertices[i]
           v_j = vertices[j]
           v_k = vertices[k]

           # 计算边向量
           e_ij = v_j - v_i
           e_ik = v_k - v_i
           e_jk = v_k - v_j
           e_ji = v_i - v_j
           e_ki = v_i - v_k
           e_kj = v_j - v_k

           # 计算cotangent值
           cot_ij = np.dot(e_ik, e_jk) / np.linalg.norm(np.cross(e_ik, e_jk))
           cot_ji = np.dot(e_jk, e_ik) / np.linalg.norm(np.cross(e_jk, e_ik))
           cot_jk = np.dot(e_ji, e_ki) / np.linalg.norm(np.cross(e_ji, e_ki))
           cot_kj = np.dot(e_ki, e_ji) / np.linalg.norm(np.cross(e_ki, e_ji))
           cot_ki = np.dot(e_kj, e_ij) / np.linalg.norm(np.cross(e_kj, e_ij))
           cot_ik = np.dot(e_ij, e_kj) / np.linalg.norm(np.cross(e_ij, e_kj))

           # 构建矩阵
           w_ij = 0.5 * cot_ki
           w_ji = 0.5 * cot_kj
           w_jk = 0.5 * cot_ik
           w_kj = 0.5 * cot_ij
           w_ki = 0.5 * cot_ji
           w_ik = 0.5 * cot_jk

           I.extend([i, j, j, k, k, i])
           J.extend([j, i, k, j, i, k])
           V.extend([w_ij, w_ji, w_jk, w_kj, w_ki, w_ik])

       # 构建稀疏矩阵
       L = sp.coo_matrix((V, (I, J)), shape=(n_vertices, n_vertices))
       L = L.tocsr()

       # 对角线元素
       rows = np.arange(n_vertices)
       diag_vals = -np.array(L.sum(axis=1)).flatten()
       L += sp.csr_matrix((diag_vals, (rows, rows)), shape=(n_vertices, n_vertices))

       return L
   ```

2. **构建质量矩阵**：
   ```python
   def mass_matrix(vertices, faces):
       n_vertices = len(vertices)
       M = sp.lil_matrix((n_vertices, n_vertices))

       for face in faces:
           i, j, k = face
           v_i = vertices[i]
           v_j = vertices[j]
           v_k = vertices[k]

           # 计算三角形面积
           area = 0.5 * np.linalg.norm(np.cross(v_j - v_i, v_k - v_i))

           # 分配面积到顶点
           for idx in [i, j, k]:
               M[idx, idx] += area / 3.0

       return M.tocsr()
   ```

3. **求解热平衡方程**：
   ```python
   def heat_weights(vertices, faces, bones, bone_vertices):
       n_vertices = len(vertices)
       n_bones = len(bones)

       # 构建Laplacian和质量矩阵
       L = cotangent_laplacian(vertices, faces)
       M = mass_matrix(vertices, faces)

       # 构建系统矩阵
       A = L

       weights = np.zeros((n_vertices, n_bones))

       for bone_idx, bone_verts in enumerate(bone_vertices):
           # 构建边界条件
           b = np.zeros(n_vertices)

           # 设置骨骼影响区域
           for vert_idx in bone_verts:
               b[vert_idx] = 1.0

           # 求解稀疏线性方程组
           x = spla.spsolve(A, b)

           # 处理负值并归一化
           x = np.maximum(x, 0)
           weights[:, bone_idx] = x

       # 归一化权重
       weights = weights / np.sum(weights, axis=1, keepdims=True)

       return weights
   ```

**优点**：
- 权重过渡非常平滑
- 考虑全局信息
- 变形效果自然

**缺点**：
- 计算复杂度高
- 需要求解大规模线性方程组

### 2. 线性混合蒙皮算法（Linear Blend Skinning）

#### 2.1 算法原理

LBS通过权重混合每个骨骼的变换矩阵来计算顶点的新位置：

```
v' = Σ(w_i * T_i * v)
```

其中：
- `v'`：变形后的顶点位置
- `w_i`：顶点对第i个骨骼的权重
- `T_i`：第i个骨骼的变换矩阵
- `v`：原始顶点位置

#### 2.2 矩阵变换

**绑定姿势矩阵**：
- 记录每个关节在绑定姿势下的全局变换矩阵
- 用于计算相对变换

**当前姿势矩阵**：
- 记录每个关节在当前动画帧下的全局变换矩阵
- 通过前向运动学(FK)计算得到

**变换矩阵计算**：
```python
def calculate_transforms(bones, joint_positions, joint_rotations):
    n_joints = len(joint_positions)
    global_transforms = []

    for i in range(n_joints):
        # 局部变换矩阵
        translation = np.eye(4)
        translation[:3, 3] = joint_positions[i]

        rotation = np.eye(4)
        rotation[:3, :3] = joint_rotations[i]

        local_transform = translation @ rotation

        # 全局变换矩阵（考虑父关节）
        if parent[i] >= 0:
            global_transform = global_transforms[parent[i]] @ local_transform
        else:
            global_transform = local_transform

        global_transforms.append(global_transform)

    return global_transforms
```

#### 2.3 LBS实现

```python
def apply_lbs(vertices, weights, bones, global_transforms, bind_transforms_inv):
    n_vertices = len(vertices)
    deformed_vertices = np.zeros((n_vertices, 3))

    # 将顶点转换为齐次坐标
    vertices_homogeneous = np.hstack([vertices, np.ones((n_vertices, 1))])

    for i in range(n_vertices):
        # 初始化变形顶点
        deformed_vertex = np.zeros(4)

        # 计算加权变换
        for j, bone in enumerate(bones):
            # 计算当前变换矩阵
            current_transform = global_transforms[bone.joint_index]
            bind_transform_inv = bind_transforms_inv[bone.joint_index]

            # 计算相对变换
            skinning_transform = current_transform @ bind_transform_inv

            # 应用权重
            weight = weights[i, j]
            deformed_vertex += weight * (skinning_transform @ vertices_homogeneous[i])

        # 转换回3D坐标
        deformed_vertices[i] = deformed_vertex[:3] / deformed_vertex[3]

    return deformed_vertices
```

### 3. 前向运动学（Forward Kinematics）

#### 3.1 算法原理

根据关节层次结构，从根关节开始逐级计算每个关节的全局变换。

#### 3.2 实现步骤

```python
def forward_kinematics(joints, rotations):
    n_joints = len(joints)
    global_matrices = [np.eye(4) for _ in range(n_joints)]

    for i, joint in enumerate(joints):
        # 获取父关节索引
        parent_idx = joint.parent

        # 局部变换矩阵
        local_matrix = np.eye(4)
        local_matrix[:3, :3] = rotations[i]  # 旋转部分
        local_matrix[:3, 3] = joint.offset    # 平移部分

        # 计算全局变换
        if parent_idx >= 0:
            global_matrices[i] = global_matrices[parent_idx] @ local_matrix
        else:
            global_matrices[i] = local_matrix

    return global_matrices
```

### 4. 骨架层次结构管理

#### 4.1 数据结构

```python
class Joint:
    def __init__(self, name, parent_idx, offset):
        self.name = name
        self.parent = parent_idx
        self.offset = np.array(offset)
        self.bind_pose = np.eye(4)
        self.current_pose = np.eye(4)

class Skeleton:
    def __init__(self):
        self.joints = []
        self.bones = []

    def add_joint(self, name, parent_idx, offset):
        joint = Joint(name, parent_idx, offset)
        self.joints.append(joint)
        return len(self.joints) - 1

    def add_bone(self, parent_joint, child_joint):
        bone = Bone(parent_joint, child_joint)
        self.bones.append(bone)
```

#### 4.2 骨架创建算法

```python
def create_skeleton_from_mesh(mesh_vertices):
    # 计算模型包围盒
    bbox_min = np.min(mesh_vertices, axis=0)
    bbox_max = np.max(mesh_vertices, axis=0)
    center = (bbox_min + bbox_max) / 2

    # 创建根关节
    skeleton = Skeleton()
    root_idx = skeleton.add_joint("root", -1, center)

    # 基于模型形状创建骨架
    # 这里可以根据具体模型特征创建合适的骨架

    return skeleton
```

### 5. 性能优化策略

#### 5.1 计算优化

**稀疏矩阵优化**：
- 使用SciPy稀疏矩阵存储权重
- 减少内存占用和计算复杂度

**向量化计算**：
- 使用NumPy向量化操作
- 避免Python循环

```python
def vectorized_lbs(vertices, weights, transforms):
    # 向量化LBS计算
    vertices_hom = np.hstack([vertices, np.ones((len(vertices), 1))])

    # 计算所有变换
    weighted_transforms = np.sum(
        weights[:, :, np.newaxis, np.newaxis] * transforms[np.newaxis, :, :, :],
        axis=1
    )

    # 应用变换
    deformed = np.einsum('nij,nj->ni', weighted_transforms, vertices_hom)
    return deformed[:, :3]
```

#### 5.2 内存优化

**延迟计算**：
- 按需计算权重和变形
- 避免重复计算

**缓存机制**：
- 缓存常用计算结果
- 减少重复计算开销

### 6. 算法复杂度分析

#### 6.1 时间复杂度

| 算法 | 时间复杂度 | 说明 |
|------|------------|------|
| 最近邻 | O(n×m) | n=顶点数，m=骨骼数 |
| 双骨插值 | O(n×m×log m) | 需要排序 |
| 热扩散 | O(n³) | 稀疏矩阵求解 |
| LBS | O(n×m) | 每个顶点每个骨骼 |

#### 6.2 空间复杂度

| 数据 | 空间复杂度 | 说明 |
|------|------------|------|
| 权重矩阵 | O(n×m) | 存储权重 |
| 变换矩阵 | O(m) | 每个骨骼一个4×4矩阵 |
| 网格数据 | O(n) | 顶点坐标 |

### 7. 算法比较与选择

#### 7.1 算法对比表

| 特性 | 最近邻 | 双骨插值 | 热扩散 |
|------|--------|----------|--------|
| 计算速度 | 快 | 中 | 慢 |
| 变形质量 | 差 | 中 | 好 |
| 内存占用 | 低 | 低 | 高 |
| 实现难度 | 简单 | 中 | 复杂 |
| 适用场景 | 预览 | 简单动画 | 高质量动画 |

#### 7.2 选择建议

- **快速预览**：使用最近邻算法
- **简单动画**：使用双骨插值算法
- **高质量动画**：使用热扩散算法
- **实时应用**：根据性能需求选择合适的算法

### 8. 数学基础

#### 8.1 矩阵运算

**4×4变换矩阵**：
```
[R | t]
[0 | 1]
```
其中R是3×3旋转矩阵，t是3×1平移向量。

**逆矩阵计算**：
```python
def inverse_transform(transform):
    R = transform[:3, :3]
    t = transform[:3, 3]

    R_inv = R.T  # 旋转矩阵的逆就是转置
    t_inv = -R_inv @ t

    inv_transform = np.eye(4)
    inv_transform[:3, :3] = R_inv
    inv_transform[:3, 3] = t_inv

    return inv_transform
```

#### 8.2 权重归一化

确保每个顶点的权重和为1：
```python
def normalize_weights(weights):
    row_sums = np.sum(weights, axis=1, keepdims=True)
    # 避免除零
    row_sums[row_sums == 0] = 1
    return weights / row_sums
```

---

**文档版本**：v1.0
**创建日期**：2025年12月31日